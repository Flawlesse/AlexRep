Описание:
	Лабораторная работа №3, совмещена со второй.
     Проект службы, которая следит за директорией Сервера, где хранится 2 директории его пользователей, Source и Target.
     Иерархия папок остаётся неизменной, в рамках лабораторной я только добавил вторую директорию Сервера, DefaultServer,
которая служит Сервером по умолчанию (на случай если не нашлось конфиг. файлов).
	Существуют 2 файла конфигурации, JSON и XML, вместе со своей схемой XSD. К ним пути прописаны в App.config (маленькое обязательное условие, применимое ко всем дефолтным значениям). 
	Оба этих файла + файл валидации XSD имеют название “config” с соотв. расширениями (у меня плохо с фантазией).
	Как уже упоминалось, в случае отсутствия конфиг. файлов или же ошибки валидации XML с XSD (если валидация необходима), дефолтный набор конфигураций будет браться из App.config.
	Также присутствуют 2 инструмента, которые тестировались мной отдельно от самой лабораторной. Это парсеры XmlParser и JsonParser, созданные в качестве отдельных классов и реализующие интерфейс IConfigurationProvider.
	Для дополнительной гибкости парсеров был также написан класс-атрибут ParsableAttribute. Напрямую как валидационный атрибут он не выступает, однако с его помощью можно задавать необязательные псевдонимы тем или иным свойствам, полям, либо же классам. Сами псевдонимы будут использоваться при парсинге, в одном и во втором парсерах.
	Здесь НЕ СУЩЕСТВУЕТ понятия неудачного парсинга. Он либо полностью удачный, либо частичный.

Принципы работы:
	Обязательно наличие действительных путей в тегах <add> в App.config, т.к. они выступают значениями по умолчанию!
	На деле в XmlParser вся эта логика была разделена на несколько частей из-за огромности кода, однако не была утеряна.	
	Парсинг происходит по следующей задумке:
• Метод T Parse<T>() каждого из классов парсеров вытаскивает сначала корень документа (для XML дополнительно сверяет с XSD схемой, если это необходимо [свойство ValidationNeeded]), а далее, смотря на наличие псевдонима у класса T, вытаскивает тег с идентичным названием (либо псевдоним, если нашёлся, либо название T через рефлексию; однако далее поиск происходит и по тому, и по другому). После же, в выбранном теге происходит поиск тега с заданным именем, а далее вызов метода 
T ParseNode<T>(selectedNode). 
• T ParseNode<T>(selectedNode) вызывается ВСЕГДА в рантайме через рефлексию типов. Почему так? Решил воспользоваться преимуществами древовидных структур и рефлексии. Работа метода как в JsonParser, так и в XmlParser, заключается в следующем: создать объект класса T с помощью Activator.CreateInstance(…) и вернуть его в оболочке object. Далее из selectedNode подоставать все атрибуты и внутренние теги с обычным текстом (для XML) или же просто достать все внутренние объекты (для JSON) и снова через рефлексию присвоить ДАЖЕ ПРИВАТНЫМ полям значения, полученные из узла и его внутренностей. 
• Говоря о внутренностях, если какая-то из них является сложным тегом или JavaScript объектом, то рекурсивно будет вызван метод 
T1 ParseNode<T1>(selectedChildNode) для данного узла, тоже через рефлексию. T1 будет  являться типом, содержащемся в типе T и парсящимся на текущем уровне вложенности. Затем будет возвращён объект класса T1 и проверен на совместимость с текущим полем класса T. Если они совместимы (их типы совпали), то производится присвоение возвращённого объекта этому полю и парсинг происходит дальше, иначе значение данного поля останется значением по умолчанию.
• Если же внутренность – примитивный тег без атрибутов с текстом посередине (для XML), либо же строка (для JSON), то происходит обыкновенное присваивание содержимого тега или строки нужному полю, с обязательной конвертацией типа в необходимый. Если конвертация произошла с ошибкой, то значение остаётся по умолчанию.
Таким образом, получаются вполне себе универсальные JSON и XML
парсеры. Единственное, чего они не умеют, это парсить массивы, однако здесь этого и не требуется.
Дополнения:	
	Помимо обычных путей логов, содержащихся в классе Logs, добавился ещё один лог, который отвечает за слежку за проблемами валидации XML документа. Он весьма доставучий, но полезный.
	Класс Manager содержит метод T GetOptions<T>(), который отвечает за поставку конфигурации для определённых классов. Их 3: ServerFolders, Logs, CryptoOptions.
	Стоит учесть, что в момент запуска службы происходит вызов конструктора класса Watcher, где поля FolderSet и LogSet получают свои настройки из объекта класса Manager через T GetOptions<T>(). Это единственное, что создаётся до запуска службы. Во время её работы при перетаскивании XML или JSON файлов будут возникать соответствующие исключения, которые будут записаны в ErrorLog.txt и ValidationLog.txt.
	Выбор XML в приоритете, за ним JSON, потом уже App.config.
